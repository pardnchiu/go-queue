// * generated by claude sonnet 4.5
package goQueue

import (
	"context"
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

func TestBasic(t *testing.T) {
	queue := New(&Config{Workers: 1})

	ctx := context.Background()
	queue.Start(ctx)

	var count atomic.Int32

	for i := 0; i < 5; i++ {
		queue.Enqueue("", func(ctx context.Context) error {
			count.Add(1)
			return nil
		})
	}

	time.Sleep(100 * time.Millisecond)

	if count.Load() != 5 {
		t.Errorf("expected 5, got %d", count.Load())
	}

	queue.Shutdown()
}

func TestShutdown(t *testing.T) {
	queue := New(&Config{Workers: 1})

	ctx := context.Background()
	queue.Start(ctx)

	var count atomic.Int32

	for i := 0; i < 5; i++ {
		queue.Enqueue("", func(ctx context.Context) error {
			count.Add(1)
			time.Sleep(10 * time.Millisecond)
			return nil
		})
	}

	queue.Shutdown() // 等待全部完成

	if count.Load() != 5 {
		t.Errorf("expected 5, got %d", count.Load())
	}
}

func TestContextCancel(t *testing.T) {
	queue := New(&Config{Workers: 1})

	ctx, cancel := context.WithCancel(context.Background())
	queue.Start(ctx)

	var count atomic.Int32

	// 塞一個會等很久的任務
	queue.Enqueue("", func(ctx context.Context) error {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(5 * time.Second):
			count.Add(1)
			return nil
		}
	})

	time.Sleep(50 * time.Millisecond) // 確保任務開始

	cancel() // 取消 context

	queue.Shutdown()

	if count.Load() != 0 {
		t.Errorf("expected 0 (cancelled), got %d", count.Load())
	}
}

func TestMultipleWorkers(t *testing.T) {
	queue := New(&Config{Workers: 4})

	ctx := context.Background()
	queue.Start(ctx)

	var count atomic.Int32
	var maxConcurrent atomic.Int32
	var current atomic.Int32

	for i := 0; i < 8; i++ {
		queue.Enqueue("", func(ctx context.Context) error {
			c := current.Add(1)
			// 記錄最大併發數
			for {
				old := maxConcurrent.Load()
				if c <= old || maxConcurrent.CompareAndSwap(old, c) {
					break
				}
			}
			time.Sleep(50 * time.Millisecond)
			current.Add(-1)
			count.Add(1)
			return nil
		})
	}

	queue.Shutdown()

	if count.Load() != 8 {
		t.Errorf("expected 8, got %d", count.Load())
	}

	if maxConcurrent.Load() < 2 {
		t.Errorf("expected concurrent execution, max was %d", maxConcurrent.Load())
	}

	t.Logf("max concurrent: %d", maxConcurrent.Load())
}

func TestPriorityOrder(t *testing.T) {
	sched := New(&Config{
		Workers: 1, // 單 worker 確保順序
		Preset: map[string]PresetConfig{
			"low":    {Priority: "low"},
			"high":   {Priority: "high"},
			"normal": {Priority: "normal"},
		},
	})

	ctx := context.Background()

	var order []string
	var mu sync.Mutex

	// 先塞任務,還沒啟動
	sched.Enqueue("low", func(ctx context.Context) error {
		mu.Lock()
		order = append(order, "low")
		mu.Unlock()
		return nil
	})

	sched.Enqueue("high", func(ctx context.Context) error {
		mu.Lock()
		order = append(order, "high")
		mu.Unlock()
		return nil
	})

	sched.Enqueue("normal", func(ctx context.Context) error {
		mu.Lock()
		order = append(order, "normal")
		mu.Unlock()
		return nil
	})

	// 啟動後執行
	sched.Start(ctx)
	sched.Shutdown()

	expected := []string{"high", "normal", "low"}
	if len(order) != len(expected) {
		t.Fatalf("expected %v, got %v", expected, order)
	}

	for i, v := range expected {
		if order[i] != v {
			t.Errorf("position %d: expected %s, got %s", i, v, order[i])
		}
	}
}
